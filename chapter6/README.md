# 요약

## 6장 타입 선언과 @types

## 아이템 45 devDependencies에 typescript와 @types 추가하기

- dependencies

* 현재 프로젝트를 실행하는 데 필수적인 라이브러리들을 포함한다.

- devDendencies

* 현재 프로젝트를 개발하고 테스트하는 데 사용되지만, 런타임에는 필요 없는 라이브러리들이 포함된다.

- peerDependencies

* 런타임에 필요하긴 하지만, 의존성을 직접 관리하지 않는 라이브러리들이 포함된다.

공통적으로 고려해야할 의 존성 두가지

- 타입스크립트 자체 의존성 고려

- 타입 의존성을 고려

* 원본 라이브러리 자체가 dependencies에 있더라도 @types 의존성은 devDependencies에 있어야 한다.

## 아이템 46 타입 선언과 관련된 세 가지 버전 이해하기

- 의존성 관리는 개발자에게 매우 힘든 일이다. 따라서 라이브러리의 전이적 의존성이 호환되는지 깊게 생각하지 않는다.

다음 3가지 사항을 추가로 고려하지 않으면 타입스크립트는 알아서 의존성 문제를 해결해 주기는 커녕, 의존성 관리를 오히려 더 복잡하게 만든다.

1. 라이브러리의 버전
2. 타입 선언의 버전
3. 타입스크립트의 버전

타입스크립트에서 일반적으로 의존성을 사용하는 방식은 다음과 같다.
특정 라이브러리를 dependencies로 설치하고, 타입 정보는 devDependencies로 설치한다.

요약

- @types 의존성과 관련된 세 가지 버전이 있다. 라이브러리 버전, @types 버전, 타입스크립트 버전이다.
- 라이브러리를 업데이트하는 경우, 해당 @types 역시 업데이트해야 한다.
- 타입 선언을 라이브러리에 포함하는 것과 DefinitelyTypes에 공개하는 것 사이의 장단점을 이해해야 한다. 타입스크립트로 작성된 라이브러리라면 타입 선언을 자체적으로 포함하고, 자바스크립트로 작성된 라이브러리라면 타입 선언을 DefinitelyTyped에 공개하는 것이 좋다.

## 아이템 47 공개 API에 등장하는 모든 타입을 익스포트하기

- 타입스크립트를 사용하다 보면, 언젠가는 서드파티의 모듈에서 익스포트되지 않은 타입 정보가 필요한 경우가 생긴다.

요약

- 공개 메서드에 등장한 어떤 형태의 타입이든 익스포트해야한다. 어차피 라이브러리 사용자가 추출할 수 있으므로, 익스포트하기 쉽게 만드는 것이 좋다.

## 아이템 48 API 주석에 TSDoc 사용하기

요약

- 익스포트도니 함수, 클래스, 타입에 주석을 달 때는 JSDoc/TsDoc 형태를 사용한다.
- @param, @returns 구문과 문서 서식을 위해 마크다운을 사용할 수 있다.
- 주석에 타입 정보를 포함하면 안된다.

## 아이템 49 콜백에서 this에 대한 타입 제공하기

- 자바스크립트에서 this 키워드는 매우 혼란스러운 기능이다.

이 장은 주로 this에 관해 다루는데 JS의 this 동작 방식을 알고 있다면 쉽게 이해할 수 있다.

이 장의 대부분의 내용은 this의 동작방식에 대해 설명하고 있어서 TypeScript와 관련된 부분은 아래와 같다.

```typescript
function addKeyListener(
  el: HTMLElement,
  fn: (this: HTMLElement, e: KeyboardEvent) => void
) {
  el.addEventListener("keydown", (e) => {
    fn(e); // this 바인딩 체크
  });
}
```

타입스크립트에서 콜백 함수의 첫 번째 매개변수에 있는 this는 특별하게 처리된다. call로 this 바인딩 없이 매개변수를 2개 넘기면 1개의 인수만을 원한다고 하며, this 바인딩을 체크해주기 때문에 실수를 방지해준다.

→ 콜백 함수에서 this를 사용해야 한다면, 타입 정보를 명시하자!

출처 : https://velog.io/@hustle-dev/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-8%EC%A3%BC%EC%B0%A8#%EC%95%84%EC%9D%B4%ED%85%9C49-%EC%BD%9C%EB%B0%B1%EC%97%90%EC%84%9C-this%EC%97%90-%EB%8C%80%ED%95%9C-%ED%83%80%EC%9E%85-%EC%A0%9C%EA%B3%B5%ED%95%98%EA%B8%B0

## 아이템 50 오버로딩 타입보다는 조건부 타입을 사용하기

```typescript
function double<T extends string | number>(
  x: T
): T extends string ? string : number;
```

요약

- 오버로딩 타입보다 조건부 타입을 사용하는 것이 좋다. 조건부 타입을 추가적인 오버로딩 없이 유니온 타입을 지원할 수 있다.

## 아이템 51 의존성 분리를 위해 미러 타입 사용하기

```typescript
function parseCSV(contents: string | Buffer): { [column: string]: string }[] {
  if (typeof contents === "object") {
    // 버퍼인경우
    return parseCSV(contents.toString("utf-8"));
  }
}
```

위와 같은 코드가 있을 때, Nodejs를 사용자를 위한 Buffer 타입이 존재하지만 이는 타입과 무관한 자바스크립트 개발자나 Nodejs와 무관한 타입스크립트 웹 개발자들에게는 의미가 없다.

→ 따라서 이러한 경우 타입을 devDependencies로 추가하기보다, 각자가 필요한 모듈만 사용할 수 있도록 구조적 타이핑을 적용하면 좋다. 그러나 타입의 대부분을 추출해야하는 경우는 명시적으로 @types 의존성을 추가하는게 낫다.
요약

- 필수가 아닌 의존성을 분리할 때는 구조적 타이핑을 사용하면 된다.
- 공개한 라이브러리를 사용하는 자바스크립트 사용자가 @types 의존성을 가지지 않게 해야 한다. 그리고 웹 개발자가 NodeJs 관련된 의존성을 가지지 않게 해야 한다.

## 아이템 52 테스팅 타입의 함정에 주의하기

이 아이템에선 테스트코드의 타입을 체크하기 위해 반환 타입을 체크하는 과정에서 발생하는 여러 문제들을 다루고 있다.

최종적으로 이 장에서 말하고자 하는 바는 DefinitelyTyped의 타입 선언을 위한 도구로 dtslint를 소개하며 이를 사용하는 것을 추천한다.

```typescript
const beatles = ["john", "paul", "george", "ringo"];
map(
  beatles,
  function (
    name, // $ExpectType string
    i, // $ExpectType number
    array // $ExpectType string[]
  ) {
    this; // $ExpectType string[]
    return name.length;
  }
); // $ExpectType number[]
```

dtslint를 사용한 테스트코드

dtslint는 할당 가능성을 체크하는 대신 각 심벌의 타입을 추출하여 글자 자체가 같은지 비교한다. 그러나 이러한 방식에도 단점이 있는데, number|string과 string|number는 같은 타입이지만 글자 자체로 보면 다르기 때문에 다른 타입으로 인식된다.

요약

- 타입을 테스트할 때는 특히 함수 타입의 동일성과 할당 가능성의 차이점을 알고 있어야 한다.
- 콜백이 있는 함수를 테스트할 때, 콜백 매개변수의 추론된 타입을 체크해야 한다. 또한, this 의 API의 일부분이라면 역시 테스트해야 한다.
- 타입 관련된 테스트에서 any를 주의해야 한다, 더 엄격한 테스트를 위해 dtslint 같은 도구를 사용하는 것이 좋다.

# 개인 독후감

## 이은택

사실 이번 챕터를 읽으면서 프로젝트를 세팅하거나, 라이브러리, 개발, 테스트 코드 작성 등을 할 때, 이렇게 까지 타입 관련 된 이슈들이 많은지 몰랐고, 해결할 수 있는 부분들이 많은 지 알게 되었다.
현실적으로 개발할 때 이 모든 것들을 체크하면서 하기는 힘들어 보이지만, 부분부분 지키지 않으면 치명적인 내용이 있다고 느껴서 관련 된 부분은 항상 신경쓰면 좋을 것 같다.

## 김련호

추상적으로 알고 있던 `@types`에 대해서 더 자세히 알게된 계기가 되었습니다. 관련되어 본 라이브러리와 타입 라이브러리의 버전이 맞지 않아서 고생했던 적이 있는데, 그때도 대충 해결했었지만 정석은 버전을 정확히 맞추는것이라는 것도 알게 되었습니다. 
그리고 라이브러리에서 `exports`되지 않은 타입이 있는 경우가 있어 자체적으로 선언하여 해결했던 적이 있는데, 아이템47에 소개된 방법이 있어서 향후에는 적용해볼 수 있을 것 같습니다. 뒤쪽에 나왔던 테스트는 와 닿지 않아서 어떤식으로 사용해야할지 더 고민해봐야 할것 같습니다.

## 강현구

타입스크립트 선언과 관련 된 프로젝트 환경설정,공개 API 개발 시 주의점 등에 대한 내용으로 아주 중요하면서도 잘 몰랐던 내용들을 이번 장을 통해 알게됐고
`dependencies` 와 `DevDependencies` 차이점에 대해 명확히 알게되었고 외부에 공개되는 모듈 개발 시 주의점도 흥미로웠다.
`this` 는 전형적으로 객체의 현재 인스턴스를 참조하는 클래스에서 가장 많이 쓰이는데 어디서 호출 됐느냐에 따라 동적으로 바뀌기 때문에 타입 정보 명시의 필요성도 인지했다.

## 김지섭

# 아젠다

# 1. 타입스크립트로만 작성한 모듈을 외부에 공개 후 설치되는 과정에서 ts compiler를 사용해서 트랜스파일링이 되어야 한다고 했을 때 외부 사용자가 운영 환경에서 해당 모듈 설치 시 `Devdependencies` 에 위치한 `package` 는 설치가 안될텐데, 어떻게 대처하면 좋을까? 
